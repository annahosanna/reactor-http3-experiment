<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Measure GET Request Time</title>
    <style>
      body {
        font-family: sans-serif;
        padding: 20px;
      }
      #output {
        margin-top: 20px;
        font-size: 1.2em;
        color: darkblue;
      }
    </style>
  </head>
  <body>
    <h3>Form Tracker</h3>
    <form id="myForm">
      <label>First Name: <input name="firstName" type="text" /></label
      ><br /><br />
      <label>Last Name: <input name="lastName" type="text" /></label
      ><br /><br />
      <label>Email: <input name="email" type="email" /></label><br /><br />
      <label>Phone: <input name="phone" type="tel" /></label><br /><br />
      <label
        >Gender: <input type="radio" name="gender" value="male" /> Male
        <input type="radio" name="gender" value="female" /> Female </label
      ><br /><br />
      <label
        >Country:
        <select name="country">
          <option value="">--Choose--</option>
          <option value="us">United States</option>
          <option value="uk">United Kingdom</option>
        </select> </label
      ><br /><br />
      <label> Comments: <textarea name="comments"></textarea></label
      ><br /><br />
      <label> Agree to terms: <input type="checkbox" name="agree" /> </label>
    </form>

    <pre id="output">Waiting for input...</pre>

    <script>
      // This should be the endpoint to get the fortune from
      const url = "https://jsonplaceholder.typicode.com/posts/1"; // Example GET endpoint

      const token = "Bearer Token";
      performance.mark("start-fetch");

      fetch(url)
        .then((response) => response.json())
        .then((data) => {
          performance.mark("end-fetch");
          performance.measure("fetch-duration", "start-fetch", "end-fetch");

          const duration = performance
            .getEntriesByName("fetch-duration")[0]
            .duration.toFixed(2);

          // Clean up marks and measures
          performance.clearMarks();
          performance.clearMeasures();

          // Instead display the fortune
          document.getElementById("output").textContent =
            `GET request took ${duration} ms.`;

          const latencyData = {
            latency: duration,
          };

          // Send JSON to server
          fetch("/report-latency", {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(latencyData),
          }).catch((err) => {
            console.error("Failed to report latency:", err);
          });
        })
        .catch((error) => {
          document.getElementById("output").textContent =
            `Error during fetch: ${error}`;
        });
      // Client side geo-location
      fetch("https://ipapi.co/json/")
        .then((res) => res.json())
        .then((data) => {
          console.log("IP-based location:", data);

          // Optionally send to your server
          fetch("https://your-server.com/api/location", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(data),
          });
        })
        .catch((err) => {
          console.error("IP location failed:", err);
        });

      // Get session ID
      function getCookie(name) {
        const cookies = document.cookie.split("; ");
        for (const cookie of cookies) {
          const [key, value] = cookie.split("=");
          if (key === name) return decodeURIComponent(value);
        }
        return null;
      }

      function showSessionID() {
        const sessionID = getCookie("SessionID");
        document.getElementById("output").textContent = sessionID
          ? `SessionID: ${sessionID}`
          : "SessionID cookie not found.";
      }

      const form = document.getElementById("myForm");
      const output = document.getElementById("output");
      const fillOrder = [];
      const filledFields = new Set();
      let lastTimestamp = null;

      function logFieldEntry(name, value) {
        const timestamp = Date.now();
        const delta = lastTimestamp ? timestamp - lastTimestamp : null;
        lastTimestamp = timestamp;

        const entry = {
          name,
          value,
          timestamp: new Date(timestamp).toISOString(),
          deltaMs: delta,
        };

        fillOrder.push(entry);
        updateDisplay();
        uploadData(fillOrder); // Send to server after each field
      }

      function updateDisplay() {
        output.textContent =
          "Field Fill Sequence:\n" +
          fillOrder
            .map((entry, i) => {
              return (
                `${i + 1}. ${entry.name} = "${entry.value}"\n    at ${entry.timestamp}` +
                (entry.deltaMs ? ` (+${entry.deltaMs}ms since last)` : "")
              );
            })
            .join("\n");
      }

      function uploadData(data) {
        fetch("https://your-server.com/api/fill-order", {
          method: "PUT", // or 'POST' depending on your API design
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ sessionId: "abc123", data }),
        })
          .then((res) => {
            if (!res.ok) {
              console.error("Upload failed:", res.status);
            } else {
              console.log("Data uploaded");
            }
          })
          .catch((err) => console.error("Upload error:", err));
      }

      // Handle various input types
      form.querySelectorAll("input, select, textarea").forEach((el) => {
        const type = el.type;

        if (type === "radio" || type === "checkbox") {
          el.addEventListener("change", (e) => {
            const name = e.target.name;
            const value = e.target.checked ? e.target.value || true : false;
            if (!filledFields.has(name) && value) {
              filledFields.add(name);
              logFieldEntry(name, value);
            }
          });
        } else {
          el.addEventListener("input", (e) => {
            const name = e.target.name;
            const value = e.target.value.trim();
            if (!filledFields.has(name) && value !== "") {
              filledFields.add(name);
              logFieldEntry(name, value);
            }
          });

          if (el.tagName === "SELECT") {
            el.addEventListener("change", (e) => {
              const name = e.target.name;
              const value = e.target.value;
              if (!filledFields.has(name) && value !== "") {
                filledFields.add(name);
                logFieldEntry(name, value);
              }
            });
          }
        }
      });
    </script>
  </body>
</html>
